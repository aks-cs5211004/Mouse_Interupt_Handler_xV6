## Traps 

Now that our APICs are initialized and set up, we can start handling interrupts.
In this part, we handle the periodic timer interrupts that we had set in
`lapic.c`.  The interrupt handler in `trap.c` prints a message everytime the
timer ticks.

In `main.c`, we call `sti` to enable interrupt handling on CPU. However before
enabling interrupts, the OS must set up the interrupt handlers. Note that the 
interrupts were disabled by running `cli` as the first instruction in the
bootloader `bootasm.S`.

Interrupt handlers are set up in the *Interrupt Descriptor Table (IDT)*
described in Section 6.10 of Intel SDM Volume 3 Part A. Basically, IDT is a
contract between the OS and the hardware: when CPU receives an interrupt, it
will change the instruction pointer `eip` to the one specified in IDT.  OS must
therefore set up the IDT before it enables interrupts. Intel hardware allows
setting different handlers for different *interrupt vectors* with support for
256 different vectors.

When an interrupt happens, the hardware writes a few things on top of the stack
as described in Figure 6-4 of Intel SDM Volume 3 Part A. We call this a
`trapframe` declared in `x86.h`. In particular, the hardware writes the error
code (err), instruction pointer at the time of interrupt (eip), code segment
(cs), and the eflags register.

`main.c` first calls `tvinit` to prepare a place in the memory: the `idt` array,
to contain 256 entries. The location of this array is later loaded into the 
*interrupt descriptor table register (IDTR)* in `idtinit` method. This mechanism
is prescribed in Section 6.10 of Intel SDM Volume 3 Part A.

The `i`th `idt` entry causes a jump to `vectori`. `vectori` is generated by
`vectors.pl` program into the `vectors.S` file. Each `vectori` basically just
writes `i` on top of the current stack, which we call the `trapno`. After
writing `trapno`, `vectori` jumps to `alltraps` defined in `trapasm.S`. This
`trapno` will be used later in common trap handler to identify which interrupt
actually happened.

Now, `alltraps` runs `pushal` to further write other registers `eax`, `ecx` etc.
in the same order as defined in `struct trapframe` declared in `x86.h`. This
`trapframe` is finally passed to the `trap` method in `trap.c`.

`trap` method handles only timer interrupt and spurious interrupts. After
handling interrupts, the trap handler calls `lapiceoi` to signal end of
interrupt to the LAPIC. As per Section 10.8.5 Intel SDM Volume 3 Part A, this
signals to the LAPIC that it can now issue the next interrupt, if any.  Spurious
interrupts are defined in Section 10.9 of Intel SDM, Volume 3 Part A.

For all the other interrupts, we just panic and crash the OS. When `trap`
returns, it falls back out to `trapasm.S` which recovers all the registers saved
by `pushal` and finally calls `iret` to jump to the `eip` that was saved by the
hardware when the interrupt had happened.

## FAQ
Why do we not call `lidt` directly in `tvinit`? Why do we have two separate
methods?

Later when we enable multi-CPU support in our OS only CPU zero will call 
`tvinit` to prepare the `idt` array, and then all the CPUs will call `lidt`.

